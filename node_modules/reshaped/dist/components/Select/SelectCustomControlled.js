"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import DropdownMenu from "../DropdownMenu/index.js";
import Icon from "../Icon/index.js";
import CheckmarkIcon from "../../icons/Checkmark.js";
import { responsivePropDependency } from "../../utilities/props.js";
import SelectRoot from "./SelectRoot.js";
import SelectTrigger from "./SelectTrigger.js";
import SelectOption from "./SelectOption.js";
import SelectOptionGroup from "./SelectOptionGroup.js";
const SelectCustomControlled = (props) => {
    const { children, value, name, placeholder, size, multiple, width = "trigger", position, fallbackPositions, } = props;
    const initialFocusRef = React.useRef(null);
    const searchStringRef = React.useRef("");
    const searchTimeoutRef = React.useRef(null);
    const dropdownRef = React.useRef(null);
    const indexedOptions = [];
    const selectedOptions = [];
    const hasValue = multiple ? value.length > 0 : value;
    const traverseOptionList = (children) => {
        return React.Children.map(children, (child, index) => {
            if (!React.isValidElement(child))
                return null;
            if (child.type === SelectOption) {
                const component = child;
                const option = component.props;
                const matchingValue = multiple ? value.includes(option.value) : option.value === value;
                const selected = matchingValue || (!placeholder && !value && index === 0);
                if (selected)
                    selectedOptions.push(option);
                indexedOptions.push({
                    value: option.value,
                    text: typeof option.children === "string" ? option.children : option.value,
                });
                return React.cloneElement(component, {
                    key: option.value,
                    onClick: (e) => {
                        option.onClick?.(e);
                        if (multiple) {
                            const nextValue = selected
                                ? value.filter((v) => v !== option.value)
                                : [...value, option.value];
                            props.onChange?.({ value: nextValue, name });
                        }
                        else {
                            props.onChange?.({ value: option.value, name });
                        }
                    },
                    startSlot: option?.startSlot || (hasValue && _jsx(Icon, { svg: selected ? CheckmarkIcon : null })),
                    attributes: {
                        ...component.props.attributes,
                        ref: selected ? initialFocusRef : undefined,
                    },
                });
            }
            if (child.type === SelectOptionGroup) {
                const component = child;
                const optionGroup = component.props;
                return React.cloneElement(component, {
                    key: optionGroup.label,
                    children: traverseOptionList(optionGroup.children),
                });
            }
            return null;
        });
    };
    // eslint-disable-next-line react-hooks/refs
    const resolvedChildren = traverseOptionList(children);
    const handleKeyDown = (e) => {
        const key = e.key;
        // Only handle alphanumeric and space characters for type-ahead
        if (key.length !== 1 || !key.match(/[\w\s]/))
            return;
        if (searchTimeoutRef.current)
            clearTimeout(searchTimeoutRef.current);
        searchStringRef.current += key.toLowerCase();
        const matchingOption = indexedOptions.find((option) => option.text.toLowerCase().startsWith(searchStringRef.current));
        if (matchingOption && dropdownRef.current) {
            const button = dropdownRef.current.querySelector(`[value="${matchingOption.value}"]`);
            button?.focus();
        }
        searchTimeoutRef.current = setTimeout(() => {
            searchStringRef.current = "";
        }, 1000);
    };
    return (_jsx(SelectRoot, { ...props, children: (props) => {
            return (_jsxs(DropdownMenu, { width: width, disableHideAnimation: true, position: position ?? "bottom", fallbackPositions: fallbackPositions ?? (position ? undefined : ["bottom", "top"]), fallbackAdjustLayout: true, fallbackMinHeight: "150px", borderRadius: responsivePropDependency(size, (size) => size === "large" || size === "xlarge" ? "medium" : "small"), initialFocusRef: initialFocusRef, children: [_jsx(DropdownMenu.Trigger, { children: (attributes) => {
                            const triggerProps = {
                                ...props,
                                inputAttributes: {
                                    ...props.inputAttributes,
                                    ...attributes,
                                },
                            };
                            return (_jsx(SelectTrigger, { ...triggerProps, value: value, children: selectedOptions?.map((option) => option.children).join(", ") }));
                        } }), _jsx(DropdownMenu.Content, { attributes: {
                            ref: dropdownRef,
                            onKeyDown: handleKeyDown,
                            // Ignore the default menu role since we're using options
                            role: undefined,
                        }, children: resolvedChildren })] }));
        } }));
};
SelectCustomControlled.displayName = "SelectCustomControlled";
export default SelectCustomControlled;
