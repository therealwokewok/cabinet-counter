"use client";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import { classNames, responsiveVariables, responsiveClassNames } from "../../utilities/props.js";
import { rafThrottle } from "../../utilities/helpers.js";
import View from "../View/index.js";
import useRTL from "../../hooks/useRTL.js";
import useIsomorphicLayoutEffect from "../../hooks/useIsomorphicLayoutEffect.js";
import CarouselControl from "./CarouselControl.js";
import s from "./Carousel.module.css";
const Carousel = (props) => {
    const { children, gap = 3, visibleItems, bleed, navigationDisplay, onChange, onScroll, instanceRef, className, attributes, } = props;
    const currentIndexRef = React.useRef(0);
    const itemRefs = React.useRef([]);
    const [mounted, setMounted] = React.useState(false);
    const [scrollPosition, setScrollPosition] = React.useState(0);
    const [isRTL] = useRTL();
    const scrollElRef = React.useRef(null);
    const prevControlElRef = React.useRef(null);
    const nextControlElRef = React.useRef(null);
    const bleedClassNames = {};
    if (typeof bleed === "object") {
        Object.entries(bleed).forEach(([key, value]) => {
            bleedClassNames[key] = typeof value === "number" && value > 0;
        });
    }
    const rootClassNames = classNames(s.root, className, ...responsiveClassNames(s, "--bleed", typeof bleed === "number" ? true : bleedClassNames));
    const handleItemRef = (el, index) => {
        itemRefs.current[index] = el;
        // TODO: Enable in React v19 since it introduced refs cleanup
        // return () => {
        // 	itemRefs.current[index] = null;
        // };
    };
    // eslint-disable-next-line react-hooks/refs
    const handleScroll = rafThrottle((event) => {
        const el = event.target;
        const firstVisibleIndex = getFirstVisibleIndex();
        setScrollPosition(el.scrollLeft);
        onScroll?.(event);
        if (currentIndexRef.current !== firstVisibleIndex)
            onChange?.({ index: firstVisibleIndex });
        currentIndexRef.current = firstVisibleIndex;
    });
    const getItemsGap = () => {
        const style = getComputedStyle(scrollElRef.current);
        // Safari returns Npx Npx as a value, we need only the first one
        const xGap = style.gap.split(" ")[0];
        return Number(xGap.replace("px", ""));
    };
    const getFirstVisibleIndex = () => {
        let resultIndex = 0;
        let sizeCalc = 0;
        const scrollEl = scrollElRef.current;
        if (!scrollEl)
            return resultIndex;
        const scrollValue = isRTL ? -scrollEl.scrollLeft : scrollEl.scrollLeft;
        const gap = getItemsGap();
        itemRefs.current.some((el, index) => {
            if (!el)
                return false;
            const visible = sizeCalc + el.clientWidth / 2 >= scrollValue;
            if (visible) {
                resultIndex = index;
                return true;
            }
            sizeCalc += el?.clientWidth + gap;
            return false;
        });
        return resultIndex;
    };
    const navigateTo = (index) => {
        const scrollEl = scrollElRef.current;
        const el = itemRefs.current[index];
        if (!el)
            return;
        scrollEl.scrollTo({
            // Browsers mirror offsetLeft value but we need to also keep the target element on the other side of the container
            // so adding addition calculations for the width of the content outside the target el
            left: isRTL ? el.offsetLeft - (scrollEl.clientWidth - el.clientWidth) : el.offsetLeft,
            top: 0,
            behavior: "smooth",
        });
    };
    const navigateRight = () => {
        const scrollEl = scrollElRef.current;
        scrollEl.scrollBy({
            left: scrollEl.clientWidth + getItemsGap(),
            top: 0,
            behavior: "smooth",
        });
    };
    const navigateLeft = () => {
        const scrollEl = scrollElRef.current;
        scrollEl.scrollBy({
            left: -scrollEl.clientWidth - getItemsGap(),
            top: 0,
            behavior: "smooth",
        });
    };
    const navigateBack = isRTL ? navigateRight : navigateLeft;
    const navigateForward = isRTL ? navigateLeft : navigateRight;
    React.useImperativeHandle(instanceRef, () => ({
        navigateBack,
        navigateForward,
        navigateTo,
    }));
    /**
     * Changing flag here since scroll ref changing won't rerender the controls and show them after SSR
     */
    useIsomorphicLayoutEffect(() => {
        setMounted(true);
    }, []);
    return (_jsxs("section", { ...attributes, className: rootClassNames, style: {
            ...responsiveVariables("--rs-carousel-items", visibleItems),
            ...responsiveVariables("--rs-carousel-bleed", bleed),
            ...attributes?.style,
        }, children: [navigationDisplay !== "hidden" && (_jsxs(_Fragment, { children: [_jsx(CarouselControl, { isRTL: isRTL, type: "back", ref: prevControlElRef, oppositeControlElRef: nextControlElRef, scrollElRef: scrollElRef, scrollPosition: scrollPosition, onClick: navigateBack, mounted: mounted }), _jsx(CarouselControl, { isRTL: isRTL, type: "forward", ref: nextControlElRef, oppositeControlElRef: prevControlElRef, scrollElRef: scrollElRef, scrollPosition: scrollPosition, onClick: navigateForward, mounted: mounted })] })), _jsx(View, { as: "ul", direction: "row", wrap: false, gap: gap, className: s.scroll, attributes: { ref: scrollElRef, onScroll: handleScroll }, children: React.Children.map(children, (child, index) => (_jsx(View.Item, { className: s.item, as: "li", attributes: { ref: (el) => handleItemRef(el, index) }, children: child }))) })] }));
};
Carousel.displayName = "Carousel";
export default Carousel;
