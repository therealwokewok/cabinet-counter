"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { onNextFrame } from "../../utilities/animation.js";
import { classNames } from "../../utilities/props.js";
import { TrapFocus } from "../../utilities/a11y/index.js";
import useToggle from "../../hooks/useToggle.js";
import useIsomorphicLayoutEffect from "../../hooks/useIsomorphicLayoutEffect.js";
import useHotkeys from "../../hooks/useHotkeys.js";
import useScrollLock from "../../hooks/useScrollLock.js";
import useIsDismissible from "../../hooks/_private/useIsDismissible.js";
import Portal from "../_private/Portal/index.js";
import s from "./Overlay.module.css";
import useHandlerRef from "../../hooks/useHandlerRef.js";
const Overlay = (props) => {
    const { active, children, transparent, blurred, overflow, onClose, onOpen, onAfterClose, onAfterOpen, disableCloseOnClick, containerRef, className, attributes, } = props;
    // Selectors wrapped with refs to simplify working with useEffect dependency array
    const onCloseRef = useHandlerRef(onClose);
    const onOpenRef = useHandlerRef(onOpen);
    const isTransparent = transparent === true;
    const opacity = isTransparent ? 0 : (1 - (transparent || 0)) * 0.7;
    const [mounted, setMounted] = React.useState(false);
    const [animated, setAnimated] = React.useState(false);
    const [offset, setOffset] = React.useState([0, 0]);
    const contentRef = React.useRef(null);
    const { lockScroll, unlockScroll } = useScrollLock({ containerRef });
    // Store overflow value in case we override it when rendering inside containerRef
    const originalOverflowRef = React.useRef(null);
    // Store mouseDown clicks that should close the overlay to then use it in mouseUp
    const isMouseDownValidRef = React.useRef(false);
    // Separating rendered and visible states to make sure animation is triggered only once overlay was added to the dom
    const { active: rendered, activate: render, deactivate: remove } = useToggle(active || false);
    const { active: visible, activate: show, deactivate: hide } = useToggle(active || false);
    const isDismissible = useIsDismissible({ active, contentRef, hasTrigger: false });
    const rootClassNames = classNames(s.root, visible && s["--visible"], isTransparent && s["--click-through"], blurred && s["--blurred"], animated && s["--animated"], containerRef && s["--contained"], overflow === "auto" && s["--overflow-auto"], className);
    const isInsideContent = (el) => {
        if (!contentRef.current)
            return;
        const firstChild = contentRef.current.firstChild;
        if (!firstChild)
            return;
        return firstChild.contains(el);
    };
    const close = React.useCallback((args) => {
        if (!visible || !isDismissible())
            return;
        if (originalOverflowRef.current && containerRef?.current) {
            containerRef.current.style.overflow = originalOverflowRef.current;
            containerRef.current.style.removeProperty("isolation");
            originalOverflowRef.current = null;
        }
        onCloseRef.current?.({ reason: args.reason });
    }, [visible, isDismissible, onCloseRef, containerRef]);
    const handleMouseDown = (event) => {
        isMouseDownValidRef.current = !isInsideContent(event.target);
    };
    const handleMouseUp = (event) => {
        const isMouseUpValid = !isInsideContent(event.target);
        const shouldClose = isMouseDownValidRef.current && isMouseUpValid && !isTransparent;
        if (!shouldClose || disableCloseOnClick)
            return;
        close({ reason: "overlay-click" });
    };
    const handleTransitionEnd = (e) => {
        if (e.propertyName !== "opacity" || e.target !== e.currentTarget)
            return;
        setAnimated(false);
        if (visible) {
            onAfterOpen?.();
            return;
        }
        unlockScroll();
        remove();
        onAfterClose?.();
    };
    useHotkeys({
        Escape: () => close({ reason: "escape-key" }),
    }, [close]);
    React.useEffect(() => {
        setAnimated(true);
        if (active && !rendered)
            render();
        if (!active && rendered)
            hide();
    }, [active, render, hide, rendered]);
    // Show overlay after it was rendered
    React.useEffect(() => {
        if (!rendered)
            return;
        if (!isTransparent)
            lockScroll();
        onNextFrame(() => {
            show();
        });
    }, [rendered, show, lockScroll, isTransparent]);
    React.useEffect(() => {
        if (!rendered || !contentRef.current)
            return;
        const trapFocus = new TrapFocus();
        const containerEl = containerRef?.current;
        if (containerEl) {
            originalOverflowRef.current = containerEl.style.overflow;
            // eslint-disable-next-line react-hooks/immutability
            containerEl.style.overflow = "hidden";
            containerEl.style.isolation = "isolate";
            setOffset([containerEl.scrollLeft, containerEl.scrollTop]);
        }
        trapFocus.trap(contentRef.current, {
            initialFocusEl: contentRef.current.querySelector("[role=dialog][tabindex='-1']"),
        });
        onOpenRef.current?.();
        return () => trapFocus.release();
    }, [rendered, onOpenRef, containerRef]);
    // Unlock scroll on unmount
    React.useEffect(() => {
        return () => unlockScroll();
    }, [unlockScroll]);
    useIsomorphicLayoutEffect(() => {
        setMounted(true);
    }, []);
    if (!rendered || !mounted)
        return null;
    return (_jsx(Portal, { targetRef: containerRef, children: _jsx(Portal.Scope, { children: (ref) => (_jsx("div", { ...attributes, ref: ref, style: {
                    "--rs-overlay-opacity": opacity,
                    "--rs-overlay-offset-x": containerRef ? `${offset[0]}px` : undefined,
                    "--rs-overlay-offset-y": containerRef ? `${offset[1]}px` : undefined,
                }, role: "button", tabIndex: -1, className: rootClassNames, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, onTransitionEnd: handleTransitionEnd, children: _jsx("div", { className: s.wrapper, children: _jsx("div", { className: s.inner, children: _jsx("div", { className: s.content, ref: contentRef, children: typeof children === "function" ? children({ active: visible }) : children }) }) }) })) }) }));
};
Overlay.displayName = "Overlay";
export default Overlay;
