var _a;
import Chain from "../Chain.js";
import * as keys from "../../constants/keys.js";
import TrapScreenReader from "./TrapScreenReader.js";
import { getActiveElement, getFocusableElements, focusElement, getFocusData } from "./focus.js";
import { getShadowRoot } from "../dom/index.js";
import { checkKeyboardMode } from "./keyboardMode.js";
class TrapFocus {
    static chain = new Chain();
    #chainId;
    #root = null;
    #trigger = null;
    #options = {};
    trapped;
    #screenReaderTrap = null;
    #mutationObserver = null;
    constructor() { }
    /**
     * Handle keyboard navigation while focus is trapped
     */
    #handleKeyDown = (event) => {
        if (event.defaultPrevented)
            return;
        if (_a.chain.tailId !== this.#chainId)
            return;
        if (!this.#root)
            return;
        const { mode, onRelease, pseudoFocus, includeTrigger } = this.#options;
        let navigationMode = "tabs";
        if (mode === "action-menu" || mode === "selection-menu" || mode === "action-bar") {
            navigationMode = "arrows";
        }
        const key = event.key;
        const isTab = key === keys.TAB;
        const isPrevTab = isTab && event.shiftKey;
        const isNextTab = isTab && !event.shiftKey;
        const isArrow = [keys.LEFT, keys.RIGHT, keys.UP, keys.DOWN].includes(key);
        const isPrevArrow = navigationMode === "arrows" && key === (mode === "action-bar" ? keys.LEFT : keys.UP);
        const isNextArrow = navigationMode === "arrows" && key === (mode === "action-bar" ? keys.RIGHT : keys.DOWN);
        const isPrev = (isPrevTab && navigationMode === "tabs") || isPrevArrow;
        const isNext = (isNextTab && navigationMode === "tabs") || isNextArrow;
        const isFocusedOnTrigger = getActiveElement(this.#root) === this.#trigger;
        const focusData = getFocusData({
            root: this.#root,
            target: isPrev ? "prev" : "next",
            options: {
                additionalElement: includeTrigger ? this.#trigger : undefined,
                circular: mode !== "action-menu" && mode !== "action-bar",
            },
        });
        // Release the trap when tab is used in navigation modes that support arrows
        const hasNavigatedOutside = (isTab && navigationMode === "arrows") ||
            (mode === "content-menu" && isTab && focusData.overflow);
        if (hasNavigatedOutside) {
            // Prevent shift + tab event to avoid focus moving after the trap release
            if (isPrevTab && !isFocusedOnTrigger)
                event.preventDefault();
            this.release();
            onRelease?.();
            return;
        }
        if (!isPrev && !isNext) {
            // Avoid page from scrolling with arrow keys while focus it trapped
            if (isArrow && (mode === "action-bar" || mode === "action-menu"))
                event.preventDefault();
            return;
        }
        event.preventDefault();
        if (!focusData.el)
            return;
        focusElement(focusData.el, { pseudoFocus });
    };
    #addListeners = () => {
        const shadowRoot = getShadowRoot(this.#root);
        const el = shadowRoot ?? document;
        el.addEventListener("keydown", this.#handleKeyDown);
    };
    #removeListeners = () => {
        const shadowRoot = getShadowRoot(this.#root);
        const el = shadowRoot ?? document;
        el.removeEventListener("keydown", this.#handleKeyDown);
    };
    /**
     * Trap the focus, add observer and keyboard event listeners
     * and create a chain item
     */
    trap = (root, options = {}) => {
        const { mode = "dialog", includeTrigger, initialFocusEl } = options;
        this.#root = root;
        this.#screenReaderTrap = new TrapScreenReader(root);
        const trigger = getActiveElement(this.#root);
        const focusable = getFocusableElements(this.#root, {
            additionalElement: includeTrigger ? trigger : undefined,
        });
        const pseudoFocus = mode === "selection-menu";
        this.#options = { ...options, pseudoFocus };
        this.#trigger = trigger;
        this.#mutationObserver = new MutationObserver(() => {
            if (!this.#root)
                return;
            const currentActiveElement = getActiveElement(this.#root);
            // Focus stayed inside the wrapper, no need to refocus
            if (this.#root.contains(currentActiveElement))
                return;
            const focusable = getFocusableElements(this.#root, {
                additionalElement: includeTrigger ? trigger : undefined,
            });
            if (!focusable.length)
                return;
            focusElement(focusable[0], { pseudoFocus });
        });
        this.#removeListeners();
        this.#mutationObserver.observe(this.#root, { childList: true, subtree: true });
        // Don't trap in case there is nothing to focus inside
        if (!focusable.length && !initialFocusEl)
            return;
        this.#addListeners();
        if (mode === "dialog")
            this.#screenReaderTrap.trap();
        // Don't add back to the chain if we're traversing back
        const tailItem = _a.chain.tailId && _a.chain.get(_a.chain.tailId);
        const currentActiveElement = getActiveElement(this.#root);
        if (!tailItem || this.#root !== tailItem.data.#root) {
            this.#chainId = _a.chain.add(this);
            // If the focus was moved manually (e.g. with autoFocus) - keep it there
            if (!this.#root.contains(currentActiveElement)) {
                focusElement(initialFocusEl || focusable[0], { pseudoFocus });
            }
        }
        this.trapped = true;
    };
    /**
     * Disabled the trap focus for the element,
     * cleanup all observers/handlers and trap for the previous element in the chain
     */
    release = (releaseOptions = {}) => {
        const { withoutFocusReturn } = releaseOptions;
        if (!this.trapped || !this.#chainId || !this.#root)
            return;
        this.trapped = false;
        if (this.#trigger && !withoutFocusReturn) {
            this.#trigger.focus({ preventScroll: !checkKeyboardMode() });
        }
        _a.chain.removePreviousTill(this.#chainId, (item) => document.body.contains(item.data.#trigger));
        this.#mutationObserver?.disconnect();
        this.#removeListeners();
        this.#screenReaderTrap?.release();
        const previousItem = _a.chain.tailId && _a.chain.get(_a.chain.tailId);
        if (previousItem && previousItem.data.#root) {
            const trapInstance = new _a();
            trapInstance.trap(previousItem.data.#root, previousItem.data.#options);
        }
    };
}
_a = TrapFocus;
export default TrapFocus;
