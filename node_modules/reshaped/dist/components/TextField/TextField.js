"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import { classNames, responsiveClassNames, responsivePropDependency } from "../../utilities/props.js";
import useElementId from "../../hooks/useElementId.js";
import { useFormControl } from "../FormControl/index.js";
import Icon from "../Icon/index.js";
import s from "./TextField.module.css";
const TextFieldSlot = (props) => {
    const { slot, icon, size, affix, position, id } = props;
    if (!icon && !slot && !affix)
        return null;
    // In case fragment is used, map over its children instead
    const renderedSlot = React.isValidElement(slot) && slot.type === React.Fragment
        ? slot.props.children
        : slot;
    const slotNode = slot &&
        React.Children.map(renderedSlot, (child) => (_jsx("div", { className: classNames(s.slot, s[`slot--position-${position}`]), children: child }, "slot")));
    const iconNode = icon && (_jsx("label", { className: classNames(s.icon, s[`icon--position-${position}`]), htmlFor: id, children: _jsx(Icon, { size: responsivePropDependency(size, (size) => {
                if (size === "large")
                    return 5;
                if (size === "xlarge")
                    return 6;
                return 4;
            }), svg: icon, autoWidth: true }) }, "icon"));
    const affixNode = affix && (_jsx("span", { className: classNames(s.affix, s[`affix--position-${position}`]), children: affix }, "affix"));
    /**
     * Start position:
     * - Icon is first to indicate a role of the input
     * - Affix is last to stay next ot the text
     * End position:
     * - Icon is first in case it's used for indicating states
     * - Slot is the last one in case it's used as a field action
     */
    const content = position === "start" ? [iconNode, slotNode, affixNode] : [iconNode, affixNode, slotNode];
    return content.filter(Boolean);
};
const TextField = (props) => {
    const { onChange, onFocus, onBlur, name, value, defaultValue, placeholder, icon, endIcon, startSlot, endSlot, startSlotPadding, endSlotPadding, prefix, suffix, size = "medium", variant = "outline", focused, multiline, rounded, className, attributes, } = props;
    const formControl = useFormControl();
    const id = useElementId(props.id);
    const inputId = formControl?.attributes.id || props.inputAttributes?.id || id;
    const disabled = formControl?.disabled || props.disabled;
    const hasError = formControl?.hasError || props.hasError;
    const inputAttributes = { ...props.inputAttributes, ...formControl?.attributes };
    const rootClassName = classNames(s.root, className, size && responsiveClassNames(s, "--size", size), hasError && s["--status-error"], disabled && s["--disabled"], focused && s["--focused"], multiline && s["--multiline"], rounded && s["--rounded"], variant && s[`--variant-${variant}`]);
    const handleChange = (event) => {
        if (!onChange)
            return;
        onChange({ name, value: event.target.value, event });
    };
    return (_jsxs("div", { ...attributes, style: {
            ...attributes?.style,
            "--rs-text-field-start-slot-padding": startSlotPadding !== undefined && startSlotPadding >= 0
                ? `calc(var(--rs-unit-x1) * ${startSlotPadding})`
                : undefined,
            "--rs-text-field-end-slot-padding": endSlotPadding !== undefined && endSlotPadding >= 0
                ? `calc(var(--rs-unit-x1) * ${endSlotPadding})`
                : undefined,
        }, "data-rs-aligner-target": true, className: rootClassName, children: [_jsx(TextFieldSlot, { position: "start", icon: icon, slot: startSlot, size: size, affix: prefix, id: id }), _jsxs("div", { className: s.inner, children: [_jsx("input", { type: "text", autoComplete: "off", ...inputAttributes, className: classNames(s.input, inputAttributes.className), disabled: disabled, name: name, placeholder: placeholder, value: value, defaultValue: defaultValue, onChange: handleChange, onFocus: onFocus || inputAttributes?.onFocus, onBlur: onBlur || inputAttributes?.onBlur, id: inputId }), _jsx(TextFieldSlot, { position: "end", icon: endIcon, slot: endSlot, size: size, affix: suffix, id: id })] })] }));
};
TextField.displayName = "TextField";
export default TextField;
