"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React, { forwardRef } from "react";
import { classNames } from "../../utilities/props.js";
import { disableUserSelect, enableUserSelect } from "../../utilities/dom/index.js";
import { resolveMixin } from "../../styles/mixin.js";
import useIsomorphicLayoutEffect from "../../hooks/useIsomorphicLayoutEffect.js";
import s from "./ScrollArea.module.css";
import useHandlerRef from "../../hooks/useHandlerRef.js";
const ScrollAreaBar = (props) => {
    const { ratio, position, vertical, onThumbMove } = props;
    const onThumbMoveRef = useHandlerRef(onThumbMove);
    const [dragging, setDragging] = React.useState(false);
    const dragStartPositionRef = React.useRef(0);
    const barRef = React.useRef(null);
    const barClassNames = classNames(s.scrollbar, vertical ? s["--scrollbar-y"] : s["--scrollbar-x"], dragging && s["--scrollbar-dragging"]);
    const handleClick = (e) => {
        const elBar = barRef.current;
        const isDirty = dragStartPositionRef.current;
        dragStartPositionRef.current = 0;
        if (isDirty)
            return;
        if (!elBar || e.currentTarget !== elBar)
            return;
        const rect = elBar.getBoundingClientRect();
        const diff = vertical ? e.pageY - rect.top : e.pageX - rect.left;
        const total = vertical ? elBar.clientHeight : elBar.clientWidth;
        // Move the center of the thumb to the clicked coordinates
        onThumbMove({ value: diff / total - ratio / 2, type: "absolute" });
    };
    const handleDrag = React.useCallback((e) => {
        if (!dragStartPositionRef.current) {
            dragStartPositionRef.current = vertical ? e.pageY : e.pageX;
        }
        const elBar = barRef.current;
        if (!elBar)
            return;
        if (!dragging)
            return;
        const diff = vertical ? e.movementY : e.movementX;
        const total = vertical ? elBar.scrollHeight : elBar.scrollWidth;
        onThumbMoveRef.current?.({ value: diff / total, type: "relative" });
    }, [vertical, dragging, onThumbMoveRef]);
    const handleDragEnd = React.useCallback(() => {
        setDragging(false);
        enableUserSelect();
    }, []);
    const handleDragStart = () => {
        setDragging(true);
        disableUserSelect();
    };
    React.useEffect(() => {
        if (!dragging)
            return;
        document.addEventListener("mousemove", handleDrag);
        document.addEventListener("mouseup", handleDragEnd);
        return () => {
            document.removeEventListener("mousemove", handleDrag);
            document.removeEventListener("mouseup", handleDragEnd);
        };
    }, [handleDrag, handleDragEnd, dragging]);
    return (_jsx("div", { className: barClassNames, style: {
            "--rs-scroll-area-ratio": ratio,
            "--rs-scroll-area-position": position,
        }, ref: barRef, onClick: handleClick, onMouseDown: handleDragStart, "aria-hidden": "true", children: _jsx("div", { className: s.thumb }) }));
};
const ScrollArea = forwardRef((props, ref) => {
    const { children, height, maxHeight, scrollbarDisplay = "hover", onScroll, className, attributes, } = props;
    const [scrollRatio, setScrollRatio] = React.useState({ x: 1, y: 1 });
    const [scrollPosition, setScrollPosition] = React.useState({ x: 0, y: 0 });
    const scrollableRef = React.useRef(null);
    const rootRef = React.useRef(null);
    const mixinStyles = resolveMixin({ height, maxHeight });
    const rootClassNames = classNames(s.root, scrollbarDisplay && s[`--display-${scrollbarDisplay}`], className);
    const contentClassNames = classNames(s.content, mixinStyles.classNames);
    const updateScroll = React.useCallback(() => {
        const scrollableEl = scrollableRef.current;
        if (!scrollableEl)
            return;
        setScrollRatio({
            x: scrollableEl.clientWidth / scrollableEl.scrollWidth,
            y: scrollableEl.clientHeight / scrollableEl.scrollHeight,
        });
    }, []);
    const handleScroll = (e) => {
        const { scrollLeft, scrollTop, clientWidth, clientHeight, scrollWidth, scrollHeight } = e.currentTarget;
        setScrollPosition({
            x: scrollLeft / scrollWidth,
            y: scrollTop / scrollHeight,
        });
        onScroll?.({
            x: scrollWidth === clientWidth ? 0 : scrollLeft / (scrollWidth - clientWidth),
            y: scrollHeight === clientHeight ? 0 : scrollTop / (scrollHeight - clientHeight),
        });
    };
    const handleThumbYMove = (args) => {
        const scrollableEl = scrollableRef.current;
        if (!scrollableEl)
            return;
        const value = scrollableEl.scrollHeight * args.value;
        if (args.type === "absolute") {
            scrollableEl.scrollTop = value;
        }
        else {
            scrollableEl.scrollTop += value;
        }
    };
    const handleThumbXMove = (args) => {
        const scrollableEl = scrollableRef.current;
        if (!scrollableEl)
            return;
        const value = scrollableEl.scrollWidth * args.value;
        if (args.type === "absolute") {
            scrollableEl.scrollLeft = value;
        }
        else {
            scrollableEl.scrollLeft += value;
        }
    };
    React.useImperativeHandle(ref, () => scrollableRef.current);
    useIsomorphicLayoutEffect(() => {
        updateScroll();
    }, [updateScroll]);
    useIsomorphicLayoutEffect(() => {
        const rootEl = rootRef.current;
        if (!rootEl)
            return;
        const observer = new ResizeObserver(updateScroll);
        observer.observe(rootEl);
        return () => observer.disconnect();
    }, [updateScroll]);
    return (_jsxs("div", { ...attributes, ref: rootRef, className: rootClassNames, children: [_jsx("div", { className: s.scrollable, ref: scrollableRef, onScroll: handleScroll, children: _jsx("div", { className: contentClassNames, style: { ...mixinStyles.variables }, children: children }) }), scrollRatio.y < 1 && scrollbarDisplay !== "hidden" && (_jsx(ScrollAreaBar, { vertical: true, onThumbMove: handleThumbYMove, ratio: scrollRatio.y, position: scrollPosition.y })), scrollRatio.x < 1 && scrollbarDisplay !== "hidden" && (_jsx(ScrollAreaBar, { onThumbMove: handleThumbXMove, ratio: scrollRatio.x, position: scrollPosition.x }))] }));
});
ScrollArea.displayName = "ScrollArea";
export default ScrollArea;
