"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import { classNames } from "../../utilities/props.js";
import useRTL from "../../hooks/useRTL.js";
import useIsomorphicLayoutEffect from "../../hooks/useIsomorphicLayoutEffect.js";
import useKeyboardArrowNavigation from "../../hooks/useKeyboardArrowNavigation.js";
import useFadeSide from "../../hooks/_private/useFadeSide.js";
import Actionable from "../Actionable/index.js";
import Icon from "../Icon/index.js";
import IconChevronRight from "../../icons/ChevronRight.js";
import IconChevronLeft from "../../icons/ChevronLeft.js";
import TabsItem from "./TabsItem.js";
import { useTabs } from "./TabsContext.js";
import s from "./Tabs.module.css";
const findParentItem = (el, rootEl) => {
    if (el === rootEl || !el)
        return null;
    if (el.classList.contains(s.listItem))
        return el;
    return findParentItem(el.parentElement, rootEl);
};
const TabsList = (props) => {
    const { children, className, attributes } = props;
    const { value, setDefaultValue, itemWidth, variant, name, direction, size, selection, setSelection, elActiveRef, elPrevActiveRef, elScrollableRef, } = useTabs();
    const [rtl] = useRTL();
    const fadeSide = useFadeSide(elScrollableRef, { disabled: itemWidth === "equal" });
    const rootClassNames = classNames(s.root, size && s[`--size-${size}`], direction && s[`--direction-${direction}`], itemWidth && s[`--item-width-${itemWidth}`], variant && s[`--variant-${variant}`], fadeSide && s["--scrollable"], (fadeSide === "start" || fadeSide === "both") && s["--fade-start"], (fadeSide === "end" || fadeSide === "both") && s["--fade-end"], className);
    const selectorClassNames = classNames(s.selector, selection.status === "idle" && s["--selector-hidden"], selection.status === "animated" && s["--selector-animated"]);
    const handleNextClick = () => {
        elScrollableRef.current.scrollBy({
            // Using ceil here since during the second navigation half of the value may be
            // smaller than during the first navigation because of the odd numbers
            left: Math.ceil(elScrollableRef.current.clientWidth / 2) * (rtl ? -1 : 1),
            behavior: "smooth",
        });
    };
    const handlePrevClick = () => {
        elScrollableRef.current.scrollBy({
            left: Math.ceil(elScrollableRef.current.clientWidth / 2) * (rtl ? 1 : -1),
            behavior: "smooth",
        });
    };
    const handleTransitionEnd = () => {
        setSelection((selectionStyle) => ({
            ...selectionStyle,
            status: "idle",
        }));
    };
    const getElementSelectionStyle = React.useCallback((el) => {
        if (!elScrollableRef.current)
            return null;
        const itemEl = findParentItem(el, elScrollableRef.current);
        if (!itemEl)
            return null;
        return {
            scaleX: itemEl.clientWidth,
            scaleY: itemEl.clientHeight,
            top: itemEl.offsetTop,
            left: itemEl.offsetLeft,
        };
    }, [elScrollableRef]);
    useKeyboardArrowNavigation({ ref: elScrollableRef, disabled: !!name });
    useIsomorphicLayoutEffect(() => {
        if (value)
            return;
        const firstItem = React.Children.toArray(children)[0];
        if (!React.isValidElement(firstItem))
            return;
        if (!firstItem || firstItem.type !== TabsItem)
            return;
        const props = firstItem.props;
        setDefaultValue(props.value);
    }, [value]);
    useIsomorphicLayoutEffect(() => {
        // Do not update selection on mount, until we receive new activeId
        if (!elPrevActiveRef.current || elPrevActiveRef.current === elActiveRef.current)
            return;
        const selectionStyle = getElementSelectionStyle(elPrevActiveRef.current);
        if (!selectionStyle)
            return;
        setSelection({ ...selectionStyle, status: "prepared" });
    }, [value, getElementSelectionStyle]);
    useIsomorphicLayoutEffect(() => {
        if (selection.status !== "prepared" || !elActiveRef.current)
            return;
        const selectionStyle = getElementSelectionStyle(elActiveRef.current);
        if (!selectionStyle)
            return;
        setSelection({ ...selectionStyle, status: "animated" });
    }, [selection]);
    return (_jsxs("div", { ...attributes, className: rootClassNames, children: [_jsx("div", { className: s.inner, ref: elScrollableRef, children: _jsxs("div", { className: s.list, role: "tablist", children: [React.Children.map(children, (child, index) => {
                            if (!React.isValidElement(child))
                                return null;
                            const props = child.props;
                            return (_jsx("div", { className: s.listItem, "data-rs-tabs-item": true, children: child }, props.value || child.key || index));
                        }), _jsx("div", { onTransitionEnd: handleTransitionEnd, className: selectorClassNames, style: {
                                "--rs-tab-selection-x": selection.left,
                                "--rs-tab-selection-y": selection.top,
                                "--rs-tab-selection-scale-x": selection.scaleX,
                                "--rs-tab-selection-scale-y": selection.scaleY,
                            } })] }) }), _jsx(Actionable, { onClick: handlePrevClick, touchHitbox: true, attributes: { "aria-hidden": true, tabIndex: -1 }, className: [
                    s.control,
                    s["control--prev"],
                    (fadeSide === "start" || fadeSide === "both") && s["control--active"],
                ], children: _jsx(Icon, { svg: IconChevronLeft, size: 5 }) }), _jsx(Actionable, { onClick: handleNextClick, touchHitbox: true, attributes: { "aria-hidden": true, tabIndex: -1 }, className: [
                    s.control,
                    s["control--next"],
                    (fadeSide === "end" || fadeSide === "both") && s["control--active"],
                ], children: _jsx(Icon, { svg: IconChevronRight, size: 5 }) })] }));
};
TabsList.displayName = "Tabs.List";
export default TabsList;
