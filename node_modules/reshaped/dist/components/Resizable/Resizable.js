"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { classNames } from "../../utilities/props.js";
import View from "../View/index.js";
import { ResizableHandleContext } from "./ResizableHandle.js";
import s from "./Resizable.module.css";
export const ResizableItem = () => null;
const PrivateResizableItem = React.forwardRef((props, ref) => {
    const { children, defaultSize, minSize, maxSize } = props;
    const itemRef = React.useRef(null);
    return (_jsx(View.Item, { grow: true, className: s.item, attributes: {
            ref: (el) => {
                if (typeof ref === "function")
                    ref(el);
                itemRef.current = el;
            },
            style: {
                "--rs-resizable-default-size": defaultSize,
                "--rs-resizable-min-size": minSize,
                "--rs-resizable-max-size": maxSize,
            },
        }, children: children }));
});
const Resizable = (props) => {
    const { children, variant = "borderless", height, direction = "row", gap = 2, className, attributes, } = props;
    const rootClassNames = classNames(s.root, s[`--direction-${direction}`], variant && s[`--variant-${variant}`], className);
    const containerRef = React.useRef(null);
    const itemsRef = React.useRef([]);
    const horizontal = direction === "row";
    let currentHandleIndex = 0;
    let currentItemIndex = 0;
    itemsRef.current = [];
    const checkedCrossedBoundaries = (args) => {
        const { item, grow, itemsSize, itemsCount } = args;
        const { minSize, maxSize } = item.props;
        const nextPx = (grow / itemsCount / 100) * itemsSize;
        const minPx = minSize && Number(minSize.replace("px", ""));
        const maxPx = maxSize && Number(maxSize?.replace("px", ""));
        if (minPx && minPx > nextPx)
            return true;
        if (maxPx && maxPx < nextPx)
            return true;
        return false;
    };
    const onDrag = (args) => {
        const { index, x, y, triggerX, triggerY } = args;
        const startItem = itemsRef.current[index];
        const endItem = itemsRef.current[index + 1];
        if (!startItem.el || !endItem.el)
            return;
        const itemsCount = itemsRef.current.length;
        // Each item has a flex-grow of 1 as default and these values get updated while dragging for the items around the handle
        // Grow value of all items besides currently updating ones
        let currentItemsGrow = itemsCount * 100;
        let itemsSize = 0;
        itemsRef.current.forEach((item, i) => {
            if (!item.el)
                return;
            itemsSize += horizontal ? item.el.clientWidth : item.el.clientHeight;
            if (i === index || i === index + 1)
                return;
            currentItemsGrow -= Number(item.el.style.flexGrow || 100);
        }, 0);
        const startSize = horizontal ? startItem.el.clientWidth : startItem.el.clientHeight;
        const startOffset = horizontal ? startItem.el.offsetLeft : startItem.el.offsetTop;
        const endSize = horizontal ? endItem.el.clientWidth : endItem.el.clientHeight;
        // Handles containing triggers are located lower based on the gap and padding inside the handle
        const gapCompensation = (horizontal ? triggerX : triggerY) - startSize - startOffset;
        const dragCoord = (horizontal ? x : y) - gapCompensation;
        // Total size of the dragging area
        const currentItemsSize = startSize + endSize;
        // x is calculated based on container but we're changing grow based on current items
        const percent = Math.min(1, Math.max(0, (dragCoord - startOffset) / currentItemsSize));
        const nextStartGrow = Math.floor(percent * currentItemsGrow);
        const nextEndGrow = Math.floor(currentItemsGrow - nextStartGrow);
        // Validate that next grow values won't break the min/max size values
        if (checkedCrossedBoundaries({ item: startItem, itemsSize, grow: nextStartGrow, itemsCount })) {
            return;
        }
        if (checkedCrossedBoundaries({ item: endItem, itemsSize, grow: nextEndGrow, itemsCount })) {
            return;
        }
        startItem.el.style.flexGrow = nextStartGrow.toString();
        endItem.el.style.flexGrow = nextEndGrow.toString();
    };
    /**
     * When passing sizes, items first get rendered with css
     * and then have to be hydrated with flexGrow to enable correct resizing
     */
    React.useEffect(() => {
        const growValues = [];
        // Calculate total size of items excluding gaps
        let totalItemsSize = 0;
        itemsRef.current.forEach((item) => {
            if (!item.el)
                return;
            totalItemsSize += horizontal ? item.el.clientWidth : item.el.clientHeight;
        });
        // Calculate flex grow values of all items rendered by css originally
        itemsRef.current.forEach((item, i) => {
            if (!item.el)
                return;
            const itemSizePercent = (horizontal ? item.el.clientWidth : item.el.clientHeight) / totalItemsSize;
            growValues[i] = itemsRef.current.length * itemSizePercent * 100;
        });
        // Apply flex grow after calculation is done to avoid layout shifts during the calculation
        itemsRef.current.forEach((item, i) => {
            if (!item.el || !growValues[i])
                return;
            item.el.style.flexGrow = growValues[i].toString();
            item.el.setAttribute("data-rs-resizable-item-mounted", "");
        });
    }, [horizontal]);
    const output = React.Children.map(children, (child) => {
        const isComponent = React.isValidElement(child);
        if (isComponent && child.props && child.type !== ResizableItem) {
            return (_jsx(ResizableHandleContext.Provider, { value: { containerRef, index: currentHandleIndex++, onDrag, direction }, children: child }));
        }
        if (isComponent && child.props && child.type === ResizableItem) {
            const index = currentHandleIndex;
            return (_jsx(PrivateResizableItem, { ...child.props, index: currentItemIndex++, ref: (el) => {
                    itemsRef.current[index] = { el, props: child.props };
                } }));
        }
        return null;
    });
    return (_jsx(View, { attributes: { ...attributes, ref: containerRef }, className: rootClassNames, height: height, direction: direction, align: "stretch", gap: gap, children: output }));
};
Resizable.displayName = "Resizable";
export default Resizable;
